/********************************************************************/
/**
 * @file   PlatformMath.cpp
 * @Author Samuel Prince (samuel.prince.quezada@gmail.com)
 * @date   2014/02/04
 * @brief  Implementation file of math and random functions
 * @bug	   No known bugs.
 */
/********************************************************************/

/************************************************************************************************************************/
/* Header files inclusion																								*/
/************************************************************************************************************************/
#include "geCoreStd.h"
#include "PlatformMath.h"

/************************************************************************************************************************/
/* Static variables definition																							*/
/************************************************************************************************************************/
static int32 s_RandomSeed;				/**< Holds the Random Seed Data (used for random numbers generation) */

/************************************************************************************************************************/
/* Functions declaration																								*/
/************************************************************************************************************************/

/************************************************************************************************************************/
/** \fn void SRandInit( int32 Seed ) 
 * @brief Function to set the initial value of the seed
 * @param [in] Seed int32 value that will be set as the starting seed
 */
/************************************************************************************************************************/
void SRandInit( int32 Seed ) 
{
	s_RandomSeed = Seed; 
}

/************************************************************************************************************************/
/** \fn float SRand()
 * @brief	Generates a random float in the range from 0 to 1 using the SRandInit seed
 * @return	A float in the range 0-1
 */
/************************************************************************************************************************/
float SRand()
{ 
	s_RandomSeed = (s_RandomSeed * RANDOM_CONSTANT_A) + RANDOM_CONSTANT_B;
	union { float f; int32 i; } Result;
	union { float f; int32 i; } Temp;
	const float SRandTemp = 1.0f;
	Temp.f = SRandTemp;
	Result.i = (Temp.i & 0xff800000) | (s_RandomSeed & 0x007fffff);
	return Fractional( Result.f );
} 

/************************************************************************************************************************/
/** \fn void GaussRandomPair(float& result_a, float& result_b, float dMean, float dStdDeviation)
 * @brief Generates two random numbers using the polar form of the Box-Muller algorithm
 *
 * The polar form of the Box-Muller transformation is able to generate two random Gaussian values on a single pass.\n
 * This method takes advantage of this situations where lots of random numbers are needed
 *
 * @param [out]	result_a Out float for the first generated number
 * @param [out]	result_b Out float for the second generated number
 * @param [in]	dMean Minimal value for both generated numbers
 * @param [in]	dStdDeviation Maximum Standard Deviation value for both numbers
 * @return		result_a and result_b will contain the generated Gaussian pair
 */
/************************************************************************************************************************/
void GaussRandomPair(float& result_a, float& result_b, float dMean, float dStdDeviation)
{
	float x1, x2, w, y1, y2;

	do
	{
		x1 = 2.0f * SRand() - 1.0f;
		x2 = 2.0f * SRand() - 1.0f;
		w = x1 * x1 + x2 * x2;
	}while( w >= 1.0f );

	w = Sqrt( (-2.0f * Loge(w) ) / w );
	y1 = x1 * w;
	y2 = x2 * w;

	result_a = ( dMean + y1 * dStdDeviation );
	result_b = ( dMean + y2 * dStdDeviation );
}

/************************************************************************************************************************/
/** \fn float GaussRandom(float dMean, float dStdDeviation)
 * @brief Return one Gaussian random number
 *
 * This function returns one of the two components generated by the Box-Muller transformation and store the other for a\n
 * future call (optimization)
 *
 * @param [in]	dMean Minimal value for both generated numbers
 * @param [in]	dStdDeviation Maximum Standard Deviation value for both numbers
 * @return		A Gaussian random float
 */
/************************************************************************************************************************/
float GaussRandom(float dMean, float dStdDeviation)
{
	static bool bUsePrecalcedResult = false;
	static float y2 = 0.0f;
	float x1, x2, w, y1;

	if( bUsePrecalcedResult )
	{
		bUsePrecalcedResult = false;
		return( dMean + y2 * dStdDeviation );
	}

	//This part is an unfolded copy of the "GaussRandomPair" function, we do this just to keep this as an optimized function
	do
	{
		x1 = 2.0f * SRand() - 1.0f;
		x2 = 2.0f * SRand() - 1.0f;
		w = x1 * x1 + x2 * x2;
	}while( w >= 1.0f );

	w = Sqrt( (-2.0f * Loge(w) ) / w );
	y1 = x1 * w;
	y2 = x2 * w;

	//Set the flag to indicate that the next call to this function doesn't need to be calculated
	bUsePrecalcedResult = true;

	return( dMean + y1 * dStdDeviation );
}
